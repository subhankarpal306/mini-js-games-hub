<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Planner: Sim</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f172a; /* Dark blue background */
            color: #e2e8f0; /* Light text */
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #game-wrapper {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 20px;
            border: 4px solid #3b82f6; /* Blue border */
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.5);
            width: 850px; /* Fixed width for better layout */
        }
        #ui-menu {
            background-color: #1e293b;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #game-grid {
            width: 600px; /* 10 tiles * 60px/tile */
            height: 600px;
            display: flex;
            flex-wrap: wrap;
            margin: 10px;
        }
        .grid-tile {
            border: 1px solid #475569;
            box-sizing: border-box;
            transition: background-color 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
        }
        .grid-tile:hover {
            opacity: 0.8;
        }
        .build-button {
            padding: 10px;
            font-weight: bold;
            border-radius: 6px;
            transition: transform 0.1s;
        }
        .build-button.active {
            box-shadow: 0 0 0 3px #fde047;
            transform: scale(1.05);
        }
    </style>
</head>
<body class="select-none">

    <h1 class="text-4xl font-extrabold mb-6 text-blue-400">City Planner: Grid Sim</h1>
    
    <div id="game-wrapper">
        
        <!-- UI Menu / Dashboard -->
        <div id="ui-menu">
            <div>
                <h2 class="text-xl font-bold text-blue-300 border-b pb-2 mb-4 border-slate-700">City Stats</h2>
                
                <div class="space-y-3 mb-6">
                    <div>
                        <p class="font-semibold text-green-400">ðŸ’° Funds:</p>
                        <span id="money-display" class="text-2xl font-extrabold text-green-400">$10,000</span>
                    </div>
                    <div>
                        <p class="font-semibold text-purple-400">ðŸ‘¥ Population:</p>
                        <span id="population-display" class="text-2xl font-extrabold text-purple-400">0</span>
                    </div>
                    <div>
                        <p class="font-semibold text-yellow-400">ðŸ˜Š Happiness:</p>
                        <span id="happiness-display" class="text-2xl font-extrabold text-yellow-400">50%</span>
                    </div>
                </div>

                <h2 class="text-xl font-bold text-blue-300 border-b pb-2 mb-4 border-slate-700">Build Menu</h2>

                <div id="build-buttons" class="space-y-2">
                    <!-- Buttons added by JS -->
                </div>
            </div>

            <div class="mt-4">
                <p id="message-display" class="text-center font-semibold text-sm h-6 text-red-400"></p>
                <button id="reset-button" class="w-full py-2 bg-slate-600 hover:bg-slate-700 font-bold rounded-lg transition duration-200 mt-3">
                    Restart City
                </button>
            </div>
        </div>

        <!-- Game Grid Area -->
        <div id="game-grid">
            <!-- Tiles injected here by JavaScript -->
        </div>
    </div>

    <script>
        // --- Setup and Constants ---
        const GRID_SIZE = 10;
        const TILE_SIZE = 60; // 60px x 60px
        
        // Simulation constants
        const SIMULATION_INTERVAL = 1000; // 1 second per simulation tick
        const BASE_HAPPINESS = 50;
        const MAX_HAPPINESS = 100;

        // --- Entity Definitions ---
        const TILE_TYPES = {
            EMPTY: { name: 'Empty', cost: 0, color: '#1f2937', icon: '' },
            RESIDENTIAL: { 
                name: 'House', cost: 500, color: '#10b981', icon: 'ðŸ ', 
                population: 10, capacity: 10
            },
            COMMERCIAL: { 
                name: 'Shop', cost: 1000, color: '#f59e0b', icon: 'ðŸª', 
                income: 50, worker_demand: 5 
            },
            ROAD: { 
                name: 'Road', cost: 50, color: '#475569', icon: 'âž–', 
                is_road: true 
            },
            PARK: { 
                name: 'Park', cost: 200, color: '#34d399', icon: 'ðŸŒ³', 
                happiness_bonus: 5
            }
        };

        // --- Game State ---
        let mapGrid = [];
        let cityStats = {};
        let selectedTool = 'RESIDENTIAL';
        let simulationIntervalId;

        // --- DOM Elements ---
        const gameGrid = document.getElementById('game-grid');
        const buildButtonsDiv = document.getElementById('build-buttons');
        const moneyDisplay = document.getElementById('money-display');
        const populationDisplay = document.getElementById('population-display');
        const happinessDisplay = document.getElementById('happiness-display');
        const messageDisplay = document.getElementById('message-display');
        const resetButton = document.getElementById('reset-button');


        // --- Utility Functions ---
        
        function getNeighbor(x, y, dx, dy) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                return mapGrid[ny][nx];
            }
            return null;
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const neighbor = getNeighbor(x, y, dx, dy);
                    if (neighbor) neighbors.push(neighbor);
                }
            }
            return neighbors;
        }

        // --- Game Logic ---

        function initializeGame() {
            // Reset State
            cityStats = {
                money: 10000,
                population: 0,
                capacity: 0,
                totalHappiness: 0, // Sum of happiness for all residents
                numResidential: 0,
                avgHappiness: BASE_HAPPINESS
            };

            // Initialize Map Grid
            mapGrid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                mapGrid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    mapGrid[y][x] = {
                        type: 'EMPTY',
                        x: x,
                        y: y,
                        entity: TILE_TYPES.EMPTY,
                        happiness: BASE_HAPPINESS // Base happiness for calculation
                    };
                }
            }
            
            // Initial map placement: Road
            mapGrid[4][0] = { ...mapGrid[4][0], type: 'ROAD', entity: TILE_TYPES.ROAD };
            mapGrid[5][0] = { ...mapGrid[5][0], type: 'ROAD', entity: TILE_TYPES.ROAD };
            mapGrid[4][9] = { ...mapGrid[4][9], type: 'ROAD', entity: TILE_TYPES.ROAD };
            mapGrid[5][9] = { ...mapGrid[5][9], type: 'ROAD', entity: TILE_TYPES.ROAD };

            gameActive = true;
            messageDisplay.textContent = "City started! Place a House (ðŸ ).";

            clearInterval(simulationIntervalId);
            simulationIntervalId = setInterval(runSimulationCycle, SIMULATION_INTERVAL);
            
            renderGrid();
            updateUI();
        }

        function handlePlacementClick(x, y) {
            if (!gameActive) return;
            
            const tile = mapGrid[y][x];
            const entityDef = TILE_TYPES[selectedTool];
            
            if (tile.type === 'EMPTY' && entityDef) {
                if (cityStats.money >= entityDef.cost) {
                    // Update State
                    cityStats.money -= entityDef.cost;
                    mapGrid[y][x] = { ...tile, type: selectedTool, entity: entityDef };
                    
                    // Update Visuals for the single tile
                    const tileEl = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    if (tileEl) {
                        tileEl.style.backgroundColor = entityDef.color;
                        tileEl.innerHTML = entityDef.icon;
                        tileEl.title = entityDef.name;
                    }
                    
                    messageDisplay.textContent = `${entityDef.name} placed for $${entityDef.cost}.`;
                    
                    // Re-run simulation to update stats instantly
                    runSimulationCycle(true); 
                } else {
                    messageDisplay.textContent = `âŒ Not enough funds to build ${entityDef.name} ($${entityDef.cost}).`;
                }
            } else if (tile.type !== 'EMPTY') {
                 messageDisplay.textContent = `ðŸš« Cannot build on an existing ${tile.entity.name}.`;
            }
        }
        
        function runSimulationCycle(instantUpdate = false) {
            let totalPopulation = 0;
            let totalCapacity = 0;
            let totalHappiness = 0;
            let totalResidential = 0;
            let totalIncome = 0;
            let totalWorkerDemand = 0;
            
            // --- Phase 1: Calculate Happiness and Demand ---
            mapGrid.forEach(row => {
                row.forEach(tile => {
                    tile.happiness = BASE_HAPPINESS;
                    
                    if (tile.type === 'RESIDENTIAL') {
                        totalResidential++;
                        totalPopulation += tile.entity.population;
                        totalCapacity += tile.entity.capacity;
                        
                        let roadAccess = false;
                        let parkBonus = 0;

                        getNeighbors(tile.x, tile.y).forEach(neighbor => {
                            if (neighbor.type === 'ROAD') roadAccess = true;
                            if (neighbor.type === 'PARK') parkBonus += neighbor.entity.happiness_bonus;
                        });
                        
                        // Happiness factors
                        if (!roadAccess) tile.happiness -= 20; // Penalty for no road
                        tile.happiness = Math.min(MAX_HAPPINESS, tile.happiness + parkBonus); // Park bonus
                        
                        totalHappiness += tile.happiness;
                    } 
                    
                    if (tile.type === 'COMMERCIAL') {
                        totalWorkerDemand += tile.entity.worker_demand;
                    }
                });
            });

            // --- Phase 2: Calculate Global Stats and Income ---
            cityStats.population = totalPopulation;
            cityStats.numResidential = totalResidential;
            cityStats.capacity = totalCapacity;
            
            cityStats.avgHappiness = totalResidential > 0 ? totalHappiness / totalResidential : BASE_HAPPINESS;
            cityStats.avgHappiness = Math.min(MAX_HAPPINESS, cityStats.avgHappiness);

            // Income calculation: Commercial zones need road access AND enough workers globally
            let commercialEfficiency = Math.min(1, cityStats.population / totalWorkerDemand);

            mapGrid.forEach(row => {
                row.forEach(tile => {
                    if (tile.type === 'COMMERCIAL') {
                        let roadAccess = getNeighbors(tile.x, tile.y).some(n => n.type === 'ROAD');
                        
                        if (roadAccess) {
                            totalIncome += tile.entity.income * commercialEfficiency;
                        }
                    }
                });
            });

            // --- Phase 3: Apply Changes and Growth ---
            if (!instantUpdate) {
                // Apply income/cost only on timed tick
                cityStats.money += totalIncome;
                
                // Population Growth (slowly grows if happiness is high)
                if (cityStats.avgHappiness > 75) {
                    cityStats.population = Math.min(cityStats.capacity, cityStats.population + 1);
                } else if (cityStats.avgHappiness < 30) {
                    cityStats.population = Math.max(0, cityStats.population - 2); // Population decline
                }
                
                if (cityStats.money < 0) {
                     endGame("BANKRUPT! Funds ran out.", 'red');
                }
            }

            updateUI();
        }

        // --- Drawing and UI ---
        
        function renderGrid() {
            gameGrid.innerHTML = '';
            gameGrid.style.width = `${GRID_SIZE * TILE_SIZE}px`;
            gameGrid.style.height = `${GRID_SIZE * TILE_SIZE}px`;

            mapGrid.forEach(row => {
                row.forEach(tile => {
                    const tileEl = document.createElement('div');
                    tileEl.classList.add('grid-tile');
                    tileEl.style.width = `${TILE_SIZE}px`;
                    tileEl.style.height = `${TILE_SIZE}px`;
                    tileEl.dataset.x = tile.x;
                    tileEl.dataset.y = tile.y;
                    tileEl.style.backgroundColor = TILE_TYPES[tile.type].color;
                    tileEl.innerHTML = TILE_TYPES[tile.type].icon;
                    tileEl.title = TILE_TYPES[tile.type].name;

                    tileEl.addEventListener('click', () => handlePlacementClick(tile.x, tile.y));
                    gameGrid.appendChild(tileEl);
                });
            });
        }
        
        function updateUI() {
            moneyDisplay.textContent = `$${Math.floor(cityStats.money).toLocaleString()}`;
            populationDisplay.textContent = `${cityStats.population.toLocaleString()} / ${cityStats.capacity.toLocaleString()}`;
            happinessDisplay.textContent = `${cityStats.avgHappiness.toFixed(0)}%`;
            
            // Happiness color feedback
            if (cityStats.avgHappiness > 80) {
                happinessDisplay.classList.remove('text-red-400', 'text-yellow-400');
                happinessDisplay.classList.add('text-green-400');
            } else if (cityStats.avgHappiness < 40) {
                happinessDisplay.classList.remove('text-green-400', 'text-yellow-400');
                happinessDisplay.classList.add('text-red-400');
            } else {
                happinessDisplay.classList.remove('text-red-400', 'text-green-400');
                happinessDisplay.classList.add('text-yellow-400');
            }
        }
        
        function setupBuildMenu() {
            buildButtonsDiv.innerHTML = '';
            Object.entries(TILE_TYPES).filter(([key]) => key !== 'EMPTY').forEach(([key, def]) => {
                const button = document.createElement('button');
                button.classList.add('build-button', 'bg-blue-500', 'hover:bg-blue-600', 'text-white');
                if (key === selectedTool) button.classList.add('active');
                
                button.textContent = `${def.icon} ${def.name} ($${def.cost.toLocaleString()})`;
                button.dataset.type = key;
                
                button.addEventListener('click', () => {
                    selectedTool = key;
                    document.querySelectorAll('.build-button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
                buildButtonsDiv.appendChild(button);
            });
        }
        
        function endGame(message, color) {
            gameActive = false;
            clearInterval(simulationIntervalId);
            messageDisplay.textContent = message;
            messageDisplay.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');
            messageDisplay.classList.add(`text-${color}-500`);
        }

        // --- Initial Launch ---
        
        resetButton.addEventListener('click', initializeGame);
        setupBuildMenu();
        initializeGame();
    </script>
</body>
</html>
